from src.data.synthetic_data import main
from src.models.train_DRRAA_module import DRRAA
import networkx as nx
import numpy as np
import torch
import torch.nn.functional as F
import matplotlib.pyplot as plt
from src.models.calcNMI import calcNMI
import matplotlib as mpl

AUCs = []
NMIs = []
seed = 4
torch.random.manual_seed(seed)
np.random.seed(seed)
alpha_values = [0.2] #[0.2, 1, 5]
iter = 5000
for idx, alpha in enumerate(alpha_values):
    print(f'Iteration number {idx} with alpha {alpha}')
    #Get synthetic data and convert to edge list
    adj_m, z, A, Z_true = main(alpha=0.05, k=10, dim=2, nsamples=100) #z is cmap
    G = nx.from_numpy_matrix(adj_m.numpy())

    temp = [x for x in nx.generate_edgelist(G, data=False)]
    edge_list = np.zeros((2, len(temp)))
    for i in range(len(temp)): 
        edge_list[0, i] = temp[i].split()[0]
        edge_list[1, i] = temp[i].split()[1]

    edge_list = torch.FloatTensor(edge_list).long()
    N = 100
    k = 3
    d = 3

    torch.random.manual_seed(seed)
    np.random.seed(seed)

    model = DRRAA(k=k,
                d=d, 
                sample_size=1, #Without random sampling
                data=edge_list)

    model.train(iterations=iter)
    auc_score, fpr, tpr = model.link_prediction()
    AUCs.append(auc_score)

    Z = F.softmax(model.Z, dim=0)
    G = F.sigmoid(model.G)
    C = (Z.T * G) / (Z.T * G).sum(0)


    embeddings = torch.matmul(model.A, torch.matmul(torch.matmul(Z, C), Z)).T
    archetypes = torch.matmul(model.A, torch.matmul(Z, C))

    if embeddings.shape[1] == 3:
        fig = plt.figure(dpi=100)
        ax = fig.add_subplot(projection='3d')
        sc = ax.scatter(embeddings[:, 0].detach().numpy(), embeddings[:, 1].detach().numpy(),
                    embeddings[:, 2].detach().numpy(), c = z)
        ax.scatter(archetypes[0, :].detach().numpy(), archetypes[1, :].detach().numpy(),
                    archetypes[2, :].detach().numpy(), marker='^', c='black')
        fig.colorbar(sc, label="Density")
    plt.savefig(f"reconstructed_synt_{alpha}.png")
    #plt.show()

    #Calculate NMI between embeddings
    NMIs.append(calcNMI(Z, Z_true).item())
    print(f'The NMI between z and z_hat is {calcNMI(Z, Z_true)}')

mpl.rcParams['font.family'] = 'Times New Roman'
fig, ax = plt.subplots(figsize=(10,5))
ax.plot(alpha_values, NMIs, '-o', label='NMIs')
ax.set_xlabel("alpha value")
ax.set_title("The NMI with different alpha values")
ax.set_ylabel("score")
ax.legend()
#plt.savefig("NMIs_raa.png")
plt.show()

fig, ax = plt.subplots(figsize=(10,5))
ax.plot(alpha_values, AUCs, '-o', label='AUCs')
ax.set_xlabel("alpha value")
ax.set_title("The AUC with different alpha values")
ax.set_ylabel("score")
ax.legend()
#plt.savefig("AUCs_raa.png")
plt.show()